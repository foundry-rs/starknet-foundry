use anyhow::{anyhow, Context, Result};
use camino::Utf8PathBuf;
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;

#[allow(dead_code)]
#[derive(Deserialize, Debug, PartialEq, Clone)]
pub struct StarknetContract {
    id: String,
    package_name: String,
    contract_name: String,
    artifacts: StarknetContractArtifactPaths,
}

#[allow(dead_code)]
#[derive(Deserialize, Debug, PartialEq, Clone)]
pub struct StarknetContractArtifactPaths {
    sierra: Utf8PathBuf,
    casm: Option<Utf8PathBuf>,
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
pub struct StarknetArtifacts {
    version: u32,
    contracts: Vec<StarknetContract>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct StarknetContractArtifacts {
    pub sierra: String,
    pub casm: Option<String>,
}

/// Get deserialized contents of `starknet_artifacts.json` file generated by Scarb
///
/// # Arguments
///
/// * `path` - A path to `starknet_artifacts.json` file.
pub fn artifacts_for_package(path: &Utf8PathBuf) -> Result<StarknetArtifacts> {
    let starknet_artifacts = fs::read_to_string(path)
        .with_context(|| format!("Failed to read {:?} contents", path.file_name()))?;
    let starknet_artifacts: StarknetArtifacts =
        serde_json::from_str(starknet_artifacts.as_str())
            .with_context(|| format!("Failed to parse {:?} contents", path.file_name()))?;
    Ok(starknet_artifacts)
}

pub fn try_get_starknet_artifacts_path(path: &Utf8PathBuf) -> Result<Option<Utf8PathBuf>> {
    let path = path.join("target/dev");
    let mut paths = fs::read_dir(&path)
        .with_context(|| format!("Failed to read directory at path = {}", path))?;
    let starknet_artifacts = paths.find_map(|path| match path {
        Ok(path) => {
            let name = path.file_name().into_string().ok()?;
            name.contains("starknet_artifacts").then_some(path.path())
        }
        Err(_) => None,
    });
    let starknet_artifacts: Option<Result<Utf8PathBuf>> = starknet_artifacts.map(|artifacts| {
        Utf8PathBuf::try_from(artifacts.clone())
            .with_context(|| format!("Failed to convert path = {:?} to Utf8PathBuf", artifacts))
    });
    starknet_artifacts.transpose()
}

pub fn get_contracts_map(path: &Utf8PathBuf) -> Result<HashMap<String, StarknetContractArtifacts>> {
    let base_path = path
        .parent()
        .ok_or_else(|| anyhow!("Failed to get parent for path = {}", path))?;
    let artifacts = artifacts_for_package(path)?;
    let mut map = HashMap::new();
    for contract in artifacts.contracts {
        let name = contract.contract_name;
        let sierra_path = base_path.join(contract.artifacts.sierra);
        let casm_path = contract
            .artifacts
            .casm
            .map(|casm_path| base_path.join(casm_path));
        let sierra = fs::read_to_string(sierra_path)?;
        let casm: Option<String> = casm_path.map(fs::read_to_string).transpose()?;
        map.insert(name, StarknetContractArtifacts { sierra, casm });
    }
    Ok(map)
}

#[cfg(test)]
mod tests {
    use super::*;
    use assert_fs::fixture::PathCopy;
    use std::process::Command;

    #[test]
    fn get_starknet_artifacts_path() {
        let temp = assert_fs::TempDir::new().unwrap();
        temp.copy_from("tests/data/declare_test", &["**/*"])
            .unwrap();
        Command::new("scarb")
            .current_dir(&temp)
            .arg("build")
            .output()
            .unwrap();

        let result = try_get_starknet_artifacts_path(
            &Utf8PathBuf::from_path_buf(temp.to_path_buf()).unwrap(),
        );
        let path = result.unwrap().unwrap();
        assert_eq!(
            path,
            temp.path()
                .join("target/dev/declare_test.starknet_artifacts.json")
        );
    }

    #[test]
    fn get_starknet_artifacts_path_for_project_without_contracts() {
        let temp = assert_fs::TempDir::new().unwrap();
        temp.copy_from("tests/data/simple_test", &["**/*"]).unwrap();
        Command::new("scarb")
            .current_dir(&temp)
            .arg("build")
            .output()
            .unwrap();

        let result = try_get_starknet_artifacts_path(
            &Utf8PathBuf::from_path_buf(temp.to_path_buf()).unwrap(),
        );
        let path = result.unwrap();
        assert!(path.is_none());
    }

    #[test]
    fn get_contracts() {
        let temp = assert_fs::TempDir::new().unwrap();
        temp.copy_from("tests/data/dispatchers", &["**/*"]).unwrap();
        Command::new("scarb")
            .current_dir(&temp)
            .arg("build")
            .output()
            .unwrap();
        let artifacts_path = temp
            .path()
            .join("target/dev/dispatchers.starknet_artifacts.json");
        let artifacts_path = Utf8PathBuf::from_path_buf(artifacts_path).unwrap();

        let contracts = get_contracts_map(&artifacts_path).unwrap();

        assert!(contracts.contains_key("ERC20"));
        assert!(contracts.contains_key("HelloStarknet"));

        let sierra_contents_erc20 =
            fs::read_to_string(temp.join("target/dev/dispatchers_ERC20.sierra.json")).unwrap();
        let casm_contents_erc20 =
            fs::read_to_string(temp.join("target/dev/dispatchers_ERC20.casm.json")).unwrap();
        let contract = contracts.get("ERC20").unwrap();
        assert_eq!(&sierra_contents_erc20, &contract.sierra);
        assert_eq!(&casm_contents_erc20, &contract.casm.clone().unwrap());

        let sierra_contents_erc20 =
            fs::read_to_string(temp.join("target/dev/dispatchers_HelloStarknet.sierra.json"))
                .unwrap();
        let casm_contents_erc20 =
            fs::read_to_string(temp.join("target/dev/dispatchers_HelloStarknet.casm.json"))
                .unwrap();
        let contract = contracts.get("HelloStarknet").unwrap();
        assert_eq!(&sierra_contents_erc20, &contract.sierra);
        assert_eq!(&casm_contents_erc20, &contract.casm.clone().unwrap());
    }
}
