# Testing Contracts' Internals

Sometimes, you want to test a function that uses Starknet context such as block number, timestamp or storage access.

Since every test is treated like a contract (with the address [`test_address`](#snforge_stdtest_address---address-of-test-contract)), you can use the aforementioned pattern to test:
- functions which are not available through the interface (but your contract uses them)
- functions which are internal
- functions performing specific operations on the contracts' storage or context data
- library calls directly in the tests

## Utilities For Testing Internals

### `contract_state_for_testing()` - State of Test Contract

This function is generated by the `#[starknet::contract]` macro.
It can be used to test functions that accept the state as an argument.

In the example below, we will use the following contract:

```rust
{{#include ../../listings/testing_contract_internals/src/contract.cairo}}
```

#### Modifying the state of an existing contract

There is a special [`interact_with_state`](../appendix/cheatcodes/interact_with_state.md) cheatcode dedicated for using `contract_state_for_testing` with a deployed contract.
By using this function, the state will be modified for the provided contract address.

```rust
{{#include ../../listings/testing_contract_internals/tests/interact_with_state.cairo}}
```

> ⚠️ **Warning**
>
> When using `contract_state_for_testing` without the `interact_with_state` cheatcode, the storage is modified in the context of the [`test_address`](#snforge_stdtest_address---address-of-test-contract) contract.
> Therefore, it is not recommended to use `contract_state_for_testing` without the cheatcode, as it can lead to unexpected results.

### `snforge_std::test_address()` - Address of Test Contract

That function returns the contract address of the test.
It is useful, when you want to:
- Mock the context (`cheat_caller_address`, `cheat_block_timestamp`, `cheat_block_number`, ...)
- Spy for events emitted in the test

Example usages:
#### 1. Mocking the context info
Example for `cheat_block_number`, same can be implemented for `cheat_caller_address`/`cheat_block_timestamp`/`elect` etc.

```rust
{{#include ../../listings/testing_contract_internals/tests/mocking_the_context_info.cairo}}
```
#### 2. Spying for events
You can use both `starknet::emit_event_syscall`, and the spies will capture the events,
emitted in a `#[test]` function, if you pass the `test_address()` as a spy parameter (or spy on all events).


Given the emitting contract implementation:
```rust
{{#include ../../listings/testing_contract_internals/src/spying_for_events.cairo}}
```
You can implement this test:

```rust
{{#include ../../listings/testing_contract_internals/tests/spying_for_events/tests.cairo}}
```

You can also use the `starknet::emit_event_syscall` directly in the tests:
```rust
{{#include ../../listings/testing_contract_internals/tests/spying_for_events/syscall_tests.cairo}}
```

## Using Library Calls With the Test State Context

Using the above utilities, you can avoid deploying a mock contract, to test a `library_call` with a `LibraryCallDispatcher`.

For contract implementation:

```rust
{{#include ../../listings/testing_contract_internals/src/using_library_calls.cairo}}
```
We use the `SafeLibraryDispatcher` like this:
```rust
{{#include ../../listings/testing_contract_internals/tests/using_library_calls.cairo}}
```
> ⚠️ **Warning**
>
> This library call will write to the `test_address` memory segment, so it can potentially **overwrite** the changes
> you make to the memory through `contract_state_for_testing` object and vice-versa.
