# Testing Contracts' Internals

Sometimes, you want to test a function which uses Starknet context (like block number, timestamp, storage access)
without deploying the actual contract.

Since every test is treated like a contract, using the aforementioned pattern you can test:
- functions which are not available through the interface (but your contract uses them)
- functions which are internal
- functions performing specific operations on the contracts' storage or context data
- library calls directly in the tests

## Utilities For Testing Internals
To facilitate such use cases, we have a handful of utilities which make a test behave like a contract.

### `contract_state_for_testing()` - State of Test Contract

This is a function generated by the `#[starknet::contract]` macro.
It can be used to test some functions which accept the state as an argument, see the example below:

```rust
{{#include ../../listings/snforge_overview/crates/testing_contract_internals/src/basic_example.cairo}}
```

This code contains some caveats:
1. To access `read/write` methods of the state fields (in this case it's `balance`) you need to also import `StoragePointerReadAccess` and `StoragePointerWriteAccess` for reading and writing respectively.
2. To access functions implemented directly on the state you need to also import an appropriate trait or function.
3. This function will always return the struct keeping track of the state of the test. It means that within one test every result of `contract_state_for_testing` actually points to the same state.

### `snforge_std::test_address()` - Address of Test Contract

That function returns the contract address of the test.
It is useful, when you want to:
- Mock the context (`cheat_caller_address`, `cheat_block_timestamp`, `cheat_block_number`, ...)
- Spy for events emitted in the test

Example usages:
#### 1. Mocking the context info
Example for `cheat_block_number`, same can be implemented for `cheat_caller_address`/`cheat_block_timestamp`/`elect` etc.

```rust
{{#include ../../listings/snforge_overview/crates/testing_contract_internals/tests/mocking_the_context_info.cairo}}
```
#### 2. Spying for events
You can use both `starknet::emit_event_syscall`, and the spies will capture the events,
emitted in a `#[test]` function, if you pass the `test_address()` as a spy parameter (or spy on all events).


Given the emitting contract implementation:
```rust
{{#include ../../listings/snforge_overview/crates/testing_contract_internals/src/spying_for_events.cairo}}
```
You can implement this test:

```rust
{{#include ../../listings/snforge_overview/crates/testing_contract_internals/tests/spying_for_events/tests.cairo}}
```

You can also use the `starknet::emit_event_syscall` directly in the tests:
```rust
{{#include ../../listings/snforge_overview/crates/testing_contract_internals/tests/spying_for_events/syscall_tests.cairo}}
```

## Using Library Calls With the Test State Context

Using the above utilities, you can avoid deploying a mock contract, to test a `library_call` with a `LibraryCallDispatcher`.

For contract implementation:

```rust
{{#include ../../listings/snforge_overview/crates/testing_contract_internals/src/using_library_calls.cairo}}
```
We use the `SafeLibraryDispatcher` like this:
```rust
{{#include ../../listings/snforge_overview/crates/testing_contract_internals/tests/using_library_calls.cairo}}
```
> ⚠️ **Warning**
>
> This library call will write to the `test_address` memory segment, so it can potentially **overwrite** the changes
> you make to the memory through `contract_state_for_testing` object and vice-versa.
