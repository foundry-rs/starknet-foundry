# Testing contracts' internals

Sometimes, you want to test a function which uses starknet context (like block number, timestamp, storage access) 
without deploying the actual contract. 

Using this pattern you can test: 
- functions which are not available through the interface (contract uses them) 
- functions which are internal
- functions performing specific operations on the contracts' storage or context data
- library calls directly in the tests

To facilitate such use cases we have a handful of utilities which make test behave like a contract

## `contract_state_for_testing()`

This is a function generated by the `#[starknet::contract]` macro.
It can be used to test some functions which accept the state as an argument, see the example below:

```rust
#[starknet::contract]
mod Contract {
    #[storage]
    struct Storage {
        balance: felt252, 
    }
    
    #[generate_trait]
    impl InternalImpl of InternalTrait {
        fn internal_function(self: @ContractState) -> felt252 {
            self.balance.read()
        }
    }
}

use tests::test_case::Contract::balanceContractMemberStateTrait;   // <--- Ad. 1

#[test]
fn test_internal() {
    let mut state = Contract::contract_state_for_testing();        // <--- Ad. 3
    state.balance.write(10);
    
    let value = Contract::InternalImpl::internal_function(@state); // <--- Ad. 2
    assert(value == 10, 'Incorrect storage value');
}
```

This code contains some caveats:
1. To access `read/write` methods of the state fields (in this case it's `balance`) you need to also import `<member_name>ContractMemberStateTrait`, where `<member_name>` is the name of the storage variable inside `Storage` struct. 
2. To test internal functions, you need to pass the created state explicitly to the function, since `self` context is not available (we're using it as a static function).
3. The memory space allocated with this function will always start in the same place, which means that 2 allocations of the "testing state" in the same test, will overwrite each other.

## `snforge_std::test_address()`

That function returns the contract address of the test.
It is useful, when you want to:
- Mock the context (prank, warp, roll, spoof)
- Spy for events emitted in the test

Example usages:
### 1. Mocking the context info
Example for `roll`, same can be implemented for `prank`/`spoof`/`warp` etc.

(only one example here for brevity)

```rust
use result::ResultTrait;
use box::BoxTrait;
use starknet::ContractAddress;
use snforge_std::{
    start_roll, stop_roll,
    test_address
};

#[test]
fn test_roll_test_state() {
    let test_address: ContractAddress = test_address();
    let old_block_number = starknet::get_block_info().unbox().block_number;

    start_roll(test_address, 234);
    let new_block_number = starknet::get_block_info().unbox().block_number;
    assert(new_block_number == 234, 'Wrong block number');

    stop_roll(test_address);
    let new_block_number = starknet::get_block_info().unbox().block_number;
    assert(new_block_number == old_block_number, 'Block num did not change back');
}
```
### 2. Spying for events
You can use both `starknet::emit_event_syscall` and `ContractState.emit` and the spies will capture the events,
emitted in a `#[test]` function, if you pass the `test_address()` as a spy parameter (or spy on all events).

[//]: # (TODO #851: Provide better examples)
```rust
use array::ArrayTrait;
use result::ResultTrait;
use starknet::SyscallResultTrait;
use starknet::ContractAddress;
use snforge_std::{ declare, ContractClassTrait, spy_events, EventSpy, EventFetcher,
    event_name_hash, EventAssertions, Event, SpyOn, test_address };

#[test]
fn test_expect_events_simple() {
    let test_address = test_address();
    let mut spy = spy_events(SpyOn::One(test_address));
    assert(spy._id == 0, 'Id should be 0');

    starknet::emit_event_syscall(array![1234].span(), array![2345].span()).unwrap_syscall();

    spy.assert_emitted(@array![
        (
            contract_address,
            Event { keys: array![1234], data: array![2345] }
        )
    ]);

    assert(spy.events.len() == 0, 'There should be no events left');
}

```

## Testing library calls directly in the tests

You can avoid deploying a mock contract, to test a `library_call` with a `LibraryCallDispatcher`.

### 1. Write the contract class

```rust
 #[starknet::contract]
mod LibraryContract {
    use result::ResultTrait;
    use starknet::ClassHash;
    use starknet::library_call_syscall;

    #[storage]
    struct Storage {
        value: felt252
    }

    #[external(v0)]
    fn get_value(
        self: @ContractState,
    ) -> felt252 {
       self.value.read()
    }

    #[external(v0)]
    fn set_value(
        ref self: ContractState,
        number: felt252
    ) {
       self.value.write(number);
    }
}
```
### 2. Write the test
```rust
use result::ResultTrait;
use starknet::{ ClassHash, library_call_syscall, ContractAddress };
use snforge_std::{ declare };

#[starknet::interface]
trait ILibraryContract<TContractState> {
    fn get_value(
        self: @TContractState,
    ) -> felt252;

    fn set_value(
        ref self: TContractState,
        number: felt252
    );
}

#[test]
fn test_library_calls() {
    let class_hash = declare('LibraryContract').class_hash;
    let lib_dispatcher = ILibraryContractSafeLibraryDispatcher { class_hash };
    let value = lib_dispatcher.get_value().unwrap();
    assert(value == 0, 'Incorrect state');
    lib_dispatcher.set_value(10);
    let value = lib_dispatcher.get_value().unwrap();
    assert(value == 10, 'Incorrect state');
}
```
> ⚠️ **Warning**
> 
> This library call will write to the `test_address()` memory segment, so it can potentially **overwrite** the changes
> you make to the memory through `contract_state_for_testing()` object and vice-versa.
