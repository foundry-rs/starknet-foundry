use crate::artifacts::StarknetArtifactsFiles;
use anyhow::{Result, anyhow};
use camino::{Utf8Path, Utf8PathBuf};
pub use command::*;
use foundry_ui::UI;
use foundry_ui::components::warning::WarningMessage;
use scarb_metadata::{Metadata, PackageId, PackageMetadata, TargetMetadata};
use semver::{BuildMetadata, Prerelease, Version, VersionReq};
use std::collections::HashMap;
use std::str::FromStr;

mod artifacts;
mod command;
pub mod metadata;
pub mod version;

pub use crate::artifacts::StarknetContractArtifacts;

const INTEGRATION_TEST_TYPE: &str = "integration";

/// Constructs `StarknetArtifactsFiles` from contracts built using test target.
///
/// If artifacts with `test_type` of `INTEGRATION_TEST_TYPE` are present, we use them base path
/// and extend with paths to other artifacts.
/// If `INTEGRATION_TEST_TYPE` is not present, we take first artifacts found.
fn get_starknet_artifacts_paths_from_test_targets(
    target_dir: &Utf8Path,
    test_targets: &HashMap<String, &TargetMetadata>,
    ui: &UI,
) -> Option<StarknetArtifactsFiles> {
    let artifact =
        |name: &str, metadata: &TargetMetadata| -> Option<(Utf8PathBuf, Option<String>)> {
            let path = format!("{name}.test.starknet_artifacts.json");
            let path = target_dir.join(&path);
            let path = if path.exists() {
                Some(path)
            } else {
                ui.println(&WarningMessage::new(&format!(
                "File = {path} missing when it should be existing, perhaps due to Scarb problem."
            )));
                None
            };

            let test_type = metadata
                .params
                .get("test-type")
                .and_then(|value| value.as_str())
                .map(ToString::to_string);

            path.map(|path| (Utf8PathBuf::from_str(path.as_str()).unwrap(), test_type))
        };

    let artifacts = test_targets
        .iter()
        .filter_map(|(target_name, metadata)| artifact(target_name, metadata))
        .collect::<Vec<_>>();

    let base_artifact_path = artifacts
        .iter()
        .find(|(_, test_type)| test_type.as_deref() == Some(INTEGRATION_TEST_TYPE))
        .cloned()
        .or_else(|| artifacts.first().cloned());

    if let Some(base_artifact) = base_artifact_path {
        let other_artifacts_paths = artifacts
            .into_iter()
            .filter(|artifact| artifact != &base_artifact)
            .map(|(path, _)| path)
            .collect();
        let (base_artifact_path, _) = base_artifact;

        Some(StarknetArtifactsFiles::new(
            base_artifact_path,
            other_artifacts_paths,
        ))
    } else {
        None
    }
}

/// Try getting the path to `starknet_artifacts.json` related to `starknet-contract` target. This file that is generated by `scarb build` command.
/// If the file is not present, `None` is returned.
fn get_starknet_artifacts_path(
    target_dir: &Utf8Path,
    target_name: &str,
    ui: &UI,
) -> Option<StarknetArtifactsFiles> {
    let path = format!("{target_name}.starknet_artifacts.json");
    let path = target_dir.join(&path);
    let path = if path.exists() {
        Some(path)
    } else {
        ui.println(&WarningMessage::new(&format!(
            "File = {path} missing. \
            This is most likely caused by `[[target.starknet-contract]]` being undefined in Scarb.toml \
            No contracts will be available for deployment"
        )));
        None
    };

    path.map(|path| StarknetArtifactsFiles::new(path, vec![]))
}

/// Get the map with `StarknetContractArtifacts` for the given package
pub fn get_contracts_artifacts_and_source_sierra_paths(
    artifacts_dir: &Utf8Path,
    package: &PackageMetadata,
    use_test_target_contracts: bool,
    ui: &UI,
) -> Result<HashMap<String, (StarknetContractArtifacts, Utf8PathBuf)>> {
    let starknet_artifact_files = if use_test_target_contracts {
        let test_targets = test_targets_by_name(package);
        get_starknet_artifacts_paths_from_test_targets(artifacts_dir, &test_targets, ui)
    } else {
        let starknet_target_name = package
            .targets
            .iter()
            .find(|target| target.kind == "starknet-contract")
            .map(|target| target.name.clone());
        starknet_target_name.and_then(|starknet_target_name| {
            get_starknet_artifacts_path(artifacts_dir, starknet_target_name.as_str(), ui)
        })
    };

    if let Some(starknet_artifact_files) = starknet_artifact_files {
        starknet_artifact_files.load_contracts_artifacts()
    } else {
        Ok(HashMap::default())
    }
}

#[must_use]
pub fn target_dir_for_workspace(metadata: &Metadata) -> Utf8PathBuf {
    metadata
        .target_dir
        .clone()
        .unwrap_or_else(|| metadata.workspace.root.join("target"))
}

/// Get a name of the given package
pub fn name_for_package(metadata: &Metadata, package: &PackageId) -> Result<String> {
    let package = metadata
        .get_package(package)
        .ok_or_else(|| anyhow!("Failed to find metadata for package = {package}"))?;

    Ok(package.name.clone())
}

fn matches_version_with_special_rules(
    package_name: &str,
    package_version: &Version,
    version_req: &VersionReq,
) -> bool {
    if package_name == "snforge_std" {
        let normalized_version = Version {
            major: package_version.major,
            minor: package_version.minor,
            patch: package_version.patch,
            // Clear pre-release and build metadata to handle exceptions in nightly builds and smoke tests
            pre: Prerelease::EMPTY,
            build: BuildMetadata::EMPTY,
        };
        version_req.matches(&normalized_version)
    } else {
        version_req.matches(package_version)
    }
}

/// Checks if the specified package has version compatible with the specified requirement
pub fn package_matches_version_requirement(
    metadata: &Metadata,
    name: &str,
    version_req: &VersionReq,
) -> Result<bool> {
    let mut packages = metadata
        .packages
        .iter()
        .filter(|package| package.name == name);

    match (packages.next(), packages.next()) {
        (Some(package), None) => Ok(matches_version_with_special_rules(
            name,
            &package.version,
            version_req,
        )),
        (None, None) => Err(anyhow!("Package {name} is not present in dependencies.")),
        _ => Err(anyhow!("Package {name} is duplicated in dependencies")),
    }
}

/// collecting by name allow us to dedup targets
/// we do it because they use same sierra and we display them without distinction anyway
#[must_use]
pub fn test_targets_by_name(package: &PackageMetadata) -> HashMap<String, &TargetMetadata> {
    fn test_target_name(target: &TargetMetadata) -> String {
        // this is logic copied from scarb: https://github.com/software-mansion/scarb/blob/90ab01cb6deee48210affc2ec1dc94d540ab4aea/extensions/scarb-cairo-test/src/main.rs#L115
        target
            .params
            .get("group-id") // by unit tests grouping
            .and_then(|v| v.as_str())
            .map(ToString::to_string)
            .unwrap_or(target.name.clone()) // else by integration test name
    }

    package
        .targets
        .iter()
        .filter(|target| target.kind == "test")
        .map(|target| (test_target_name(target), target))
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::metadata::MetadataCommandExt;
    use assert_fs::TempDir;
    use assert_fs::fixture::{FileWriteStr, PathChild, PathCopy};
    use camino::Utf8PathBuf;
    use indoc::{formatdoc, indoc};
    use std::fs;
    use std::str::FromStr;

    pub(crate) fn setup_package(package_name: &str) -> TempDir {
        let temp = TempDir::new().unwrap();
        temp.copy_from(
            format!("tests/data/{package_name}"),
            &["**/*.cairo", "**/*.toml"],
        )
        .unwrap();
        temp.copy_from("../../", &[".tool-versions"]).unwrap();

        let snforge_std_path = Utf8PathBuf::from_str("../../snforge_std")
            .unwrap()
            .canonicalize_utf8()
            .unwrap()
            .to_string()
            .replace('\\', "/");

        let manifest_path = temp.child("Scarb.toml");
        manifest_path
            .write_str(&formatdoc!(
                r#"
                [package]
                name = "{}"
                version = "0.1.0"

                [dependencies]
                starknet = "2.4.0"
                snforge_std = {{ path = "{}" }}

                [[target.starknet-contract]]

                [[tool.snforge.fork]]
                name = "FIRST_FORK_NAME"
                url = "http://some.rpc.url"
                block_id.number = "1"

                [[tool.snforge.fork]]
                name = "SECOND_FORK_NAME"
                url = "http://some.rpc.url"
                block_id.hash = "1"

                [[tool.snforge.fork]]
                name = "THIRD_FORK_NAME"
                url = "http://some.rpc.url"
                block_id.tag = "latest"
                "#,
                package_name,
                snforge_std_path
            ))
            .unwrap();

        temp
    }

    #[test]
    fn get_starknet_artifacts_path_for_standard_build() {
        let temp = setup_package("basic_package");

        ScarbCommand::new_with_stdio()
            .current_dir(temp.path())
            .arg("build")
            .run()
            .unwrap();

        let ui = UI::default();
        let path = get_starknet_artifacts_path(
            &Utf8PathBuf::from_path_buf(temp.to_path_buf().join("target").join("dev")).unwrap(),
            "basic_package",
            &ui,
        )
        .unwrap();

        assert_eq!(
            path,
            StarknetArtifactsFiles::new(
                Utf8PathBuf::from_path_buf(
                    temp.path()
                        .join("target/dev/basic_package.starknet_artifacts.json")
                )
                .unwrap(),
                vec![]
            )
        );
    }

    #[test]
    fn get_starknet_artifacts_path_for_test_build() {
        let temp = setup_package("basic_package");

        ScarbCommand::new_with_stdio()
            .current_dir(temp.path())
            .arg("build")
            .arg("--test")
            .run()
            .unwrap();

        let metadata = ScarbCommand::metadata()
            .current_dir(temp.path())
            .run()
            .unwrap();

        let package = metadata
            .packages
            .iter()
            .find(|p| p.name == "basic_package")
            .unwrap();

        let ui = UI::default();
        let path = get_starknet_artifacts_paths_from_test_targets(
            &Utf8PathBuf::from_path_buf(temp.join("target").join("dev")).unwrap(),
            &test_targets_by_name(package),
            &ui,
        )
        .unwrap();

        assert_eq!(
            path,
            StarknetArtifactsFiles::new(
                Utf8PathBuf::from_path_buf(
                    temp.path()
                        .join("target/dev/basic_package_unittest.test.starknet_artifacts.json")
                )
                .unwrap(),
                vec![],
            )
        );
    }

    #[test]
    fn get_starknet_artifacts_path_for_test_build_when_integration_tests_exist() {
        let temp = setup_package("basic_package");
        let tests_dir = temp.join("tests");
        fs::create_dir(&tests_dir).unwrap();

        temp.child(tests_dir.join("test.cairo"))
            .write_str(indoc!(
                r"
                #[test]
                fn mock_test() {
                    assert!(true);
                }
            "
            ))
            .unwrap();

        ScarbCommand::new_with_stdio()
            .current_dir(temp.path())
            .arg("build")
            .arg("--test")
            .run()
            .unwrap();

        let metadata = ScarbCommand::metadata()
            .current_dir(temp.path())
            .run()
            .unwrap();

        let package = metadata
            .packages
            .iter()
            .find(|p| p.name == "basic_package")
            .unwrap();

        let ui = UI::default();
        let path = get_starknet_artifacts_paths_from_test_targets(
            &Utf8PathBuf::from_path_buf(temp.to_path_buf().join("target").join("dev")).unwrap(),
            &test_targets_by_name(package),
            &ui,
        )
        .unwrap();

        assert_eq!(
            path,
            StarknetArtifactsFiles::new(
                Utf8PathBuf::from_path_buf(
                    temp.path().join(
                        "target/dev/basic_package_integrationtest.test.starknet_artifacts.json"
                    )
                )
                .unwrap(),
                vec![
                    Utf8PathBuf::from_path_buf(
                        temp.path()
                            .join("target/dev/basic_package_unittest.test.starknet_artifacts.json")
                    )
                    .unwrap(),
                ]
            ),
        );
    }

    #[test]
    fn package_matches_version_requirement_test() {
        let temp = setup_package("basic_package");

        let manifest_path = temp.child("Scarb.toml");
        manifest_path
            .write_str(&formatdoc!(
                r#"
                [package]
                name = "version_checker"
                version = "0.1.0"

                [[target.starknet-contract]]
                sierra = true

                [dependencies]
                starknet = "2.9.4"
                "#,
            ))
            .unwrap();

        let scarb_metadata = ScarbCommand::metadata()
            .inherit_stderr()
            .current_dir(temp.path())
            .run()
            .unwrap();

        assert!(
            package_matches_version_requirement(
                &scarb_metadata,
                "starknet",
                // TODO: Update to 2.12
                &VersionReq::parse("2.11").unwrap(),
            )
            .unwrap()
        );

        assert!(
            package_matches_version_requirement(
                &scarb_metadata,
                "not_existing",
                &VersionReq::parse("2.5").unwrap(),
            )
            .is_err()
        );

        assert!(
            !package_matches_version_requirement(
                &scarb_metadata,
                "starknet",
                &VersionReq::parse("2.13").unwrap(),
            )
            .unwrap()
        );
    }

    #[test]
    fn get_starknet_artifacts_path_for_project_with_different_package_and_target_name() {
        let temp = setup_package("basic_package");

        let snforge_std_path = Utf8PathBuf::from_str("../../snforge_std")
            .unwrap()
            .canonicalize_utf8()
            .unwrap()
            .to_string()
            .replace('\\', "/");

        let scarb_path = temp.child("Scarb.toml");
        scarb_path
            .write_str(&formatdoc!(
                r#"
                [package]
                name = "basic_package"
                version = "0.1.0"

                [dependencies]
                starknet = "2.4.0"
                snforge_std = {{ path = "{}" }}

                [[target.starknet-contract]]
                name = "essa"
                sierra = true
                "#,
                snforge_std_path
            ))
            .unwrap();

        ScarbCommand::new_with_stdio()
            .current_dir(temp.path())
            .arg("build")
            .run()
            .unwrap();

        let ui = UI::default();
        let path = get_starknet_artifacts_path(
            &Utf8PathBuf::from_path_buf(temp.to_path_buf().join("target").join("dev")).unwrap(),
            "essa",
            &ui,
        )
        .unwrap();

        assert_eq!(
            path,
            StarknetArtifactsFiles::new(
                Utf8PathBuf::from_path_buf(
                    temp.path().join("target/dev/essa.starknet_artifacts.json")
                )
                .unwrap(),
                vec![]
            )
        );
    }

    #[test]
    fn get_starknet_artifacts_path_for_project_without_starknet_target() {
        let temp = setup_package("empty_lib");

        let manifest_path = temp.child("Scarb.toml");
        manifest_path
            .write_str(indoc!(
                r#"
            [package]
            name = "empty_lib"
            version = "0.1.0"
            "#,
            ))
            .unwrap();

        ScarbCommand::new_with_stdio()
            .current_dir(temp.path())
            .arg("build")
            .run()
            .unwrap();

        let ui = UI::default();
        let path = get_starknet_artifacts_path(
            &Utf8PathBuf::from_path_buf(temp.to_path_buf().join("target").join("dev")).unwrap(),
            "empty_lib",
            &ui,
        );
        assert!(path.is_none());
    }

    #[test]
    fn get_starknet_artifacts_path_for_project_without_scarb_build() {
        let temp = setup_package("basic_package");

        let ui = UI::default();
        let path = get_starknet_artifacts_path(
            &Utf8PathBuf::from_path_buf(temp.to_path_buf().join("target").join("dev")).unwrap(),
            "basic_package",
            &ui,
        );
        assert!(path.is_none());
    }

    #[test]
    fn get_contracts() {
        let temp = setup_package("basic_package");

        ScarbCommand::new_with_stdio()
            .current_dir(temp.path())
            .arg("build")
            .run()
            .unwrap();

        let metadata = ScarbCommand::metadata()
            .inherit_stderr()
            .manifest_path(temp.join("Scarb.toml"))
            .run()
            .unwrap();

        let target_dir = target_dir_for_workspace(&metadata).join("dev");
        let package = metadata.packages.first().unwrap();

        let ui = UI::default();
        let contracts = get_contracts_artifacts_and_source_sierra_paths(
            target_dir.as_path(),
            package,
            false,
            &ui,
        )
        .unwrap();

        assert!(contracts.contains_key("ERC20"));
        assert!(contracts.contains_key("HelloStarknet"));

        let sierra_contents_erc20 =
            fs::read_to_string(temp.join("target/dev/basic_package_ERC20.contract_class.json"))
                .unwrap();

        let contract = contracts.get("ERC20").unwrap();
        assert_eq!(&sierra_contents_erc20, &contract.0.sierra);
        assert!(!contract.0.casm.is_empty());

        let sierra_contents_erc20 = fs::read_to_string(
            temp.join("target/dev/basic_package_HelloStarknet.contract_class.json"),
        )
        .unwrap();
        let contract = contracts.get("HelloStarknet").unwrap();
        assert_eq!(&sierra_contents_erc20, &contract.0.sierra);
        assert!(!contract.0.casm.is_empty());
    }

    #[test]
    fn get_name_for_package() {
        let temp = setup_package("basic_package");
        let scarb_metadata = ScarbCommand::metadata()
            .inherit_stderr()
            .current_dir(temp.path())
            .run()
            .unwrap();

        let package_name =
            name_for_package(&scarb_metadata, &scarb_metadata.workspace.members[0]).unwrap();

        assert_eq!(&package_name, "basic_package");
    }
}
