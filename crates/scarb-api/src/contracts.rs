use anyhow::{anyhow, Context, Result};
use camino::{Utf8Path, Utf8PathBuf};
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use universal_sierra_compiler_api::{compile_sierra_at_path, SierraType};

#[derive(Deserialize, Debug, PartialEq, Clone)]
struct StarknetArtifacts {
    version: u32,
    contracts: Vec<StarknetContract>,
}

#[allow(dead_code)]
#[derive(Deserialize, Debug, PartialEq, Clone)]
pub(crate) struct StarknetContract {
    pub id: String,
    pub package_name: String,
    pub contract_name: String,
    pub artifacts: StarknetContractArtifactPaths,
}

#[allow(dead_code)]
#[derive(Deserialize, Debug, PartialEq, Clone)]
pub(crate) struct StarknetContractArtifactPaths {
    pub sierra: Utf8PathBuf,
}

/// Get deserialized contents of `starknet_artifacts.json` file generated by Scarb
///
/// # Arguments
///
/// * `path` - A path to `starknet_artifacts.json` file.
fn artifacts_for_package(path: &Utf8Path) -> Result<StarknetArtifacts> {
    let starknet_artifacts =
        fs::read_to_string(path).with_context(|| format!("Failed to read {path:?} contents"))?;
    let starknet_artifacts: StarknetArtifacts =
        serde_json::from_str(starknet_artifacts.as_str())
            .with_context(|| format!("Failed to parse {path:?} contents. Make sure you have enabled sierra code generation in Scarb.toml"))?;
    Ok(starknet_artifacts)
}

/// Contains compiled Starknet artifacts
#[derive(Debug, PartialEq, Clone)]
pub struct StarknetContractArtifacts {
    /// Compiled sierra code
    pub sierra: String,
    /// Compiled casm code
    pub casm: String,
}

impl StarknetContractArtifacts {
    fn from_scarb_contract_artifact(
        starknet_contract: &StarknetContract,
        base_path: &Utf8Path,
    ) -> Result<Self> {
        let sierra_path = base_path.join(starknet_contract.artifacts.sierra.clone());
        let sierra = fs::read_to_string(sierra_path)?;

        let casm = compile_sierra_at_path(
            starknet_contract.artifacts.sierra.as_str(),
            Some(base_path.as_std_path()),
            &SierraType::Contract,
        )?;

        Ok(Self { sierra, casm })
    }
}

pub(crate) fn load_contracts_artifacts_and_source_sierra_paths(
    contracts_path: &Utf8PathBuf,
) -> Result<HashMap<String, (StarknetContractArtifacts, Utf8PathBuf)>> {
    let base_path = contracts_path
        .parent()
        .ok_or_else(|| anyhow!("Failed to get parent for path = {}", &contracts_path))?;
    let artifacts = artifacts_for_package(contracts_path)?;
    let mut map = HashMap::new();

    for ref contract in artifacts.contracts {
        let name = contract.contract_name.clone();
        let contract_artifacts =
            StarknetContractArtifacts::from_scarb_contract_artifact(contract, base_path)?;

        let sierra_path = base_path.join(contract.artifacts.sierra.clone());

        map.insert(name.clone(), (contract_artifacts, sierra_path));
    }
    Ok(map)
}

#[cfg(test)]
mod tests {
    use crate::ScarbCommand;
    use assert_fs::fixture::{FileTouch, FileWriteStr, PathChild, PathCopy};
    use assert_fs::TempDir;
    use camino::Utf8PathBuf;

    use super::*;

    #[test]
    fn parsing_starknet_artifacts() {
        let temp = crate::tests::setup_package("basic_package");

        ScarbCommand::new_with_stdio()
            .current_dir(temp.path())
            .arg("build")
            .run()
            .unwrap();

        let artifacts_path = temp
            .path()
            .join("target/dev/basic_package.starknet_artifacts.json");
        let artifacts_path = Utf8PathBuf::from_path_buf(artifacts_path).unwrap();

        let artifacts = artifacts_for_package(&artifacts_path).unwrap();

        assert!(!artifacts.contracts.is_empty());
    }

    #[test]
    fn parsing_starknet_artifacts_on_invalid_file() {
        let temp = TempDir::new().unwrap();
        temp.copy_from("../../", &[".tool-versions"]).unwrap();
        let path = temp.child("wrong.json");
        path.touch().unwrap();
        path.write_str("\"aa\": {}").unwrap();
        let artifacts_path = Utf8PathBuf::from_path_buf(path.to_path_buf()).unwrap();

        let result = artifacts_for_package(&artifacts_path);
        let err = result.unwrap_err();

        assert!(err.to_string().contains(&format!("Failed to parse {artifacts_path:?} contents. Make sure you have enabled sierra code generation in Scarb.toml")));
    }
}
